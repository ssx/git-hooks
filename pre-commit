#!/usr/bin/env bash
#
# pre-commit runner
#
# Discovers check scripts from pre-commit.d/<scope>/ and runs them against
# staged files. Each file's extension is resolved to a scope via EXT_MAP.
#
# ── Extension → scope mapping ─────────────────────────────────────────────────
# Maps a file extension to a scope directory under pre-commit.d/.
# Format: "extension:scope"
#
# Files whose extension is not listed here only run "all" checks.
# A scope directory doesn't need to exist — it's silently skipped.
#
EXT_MAP=(
  "php:php"
  "phtml:php"     # Magento/PHP templates treated as PHP
# "ts:js"         # example: TypeScript runs js/ checks
# "scss:css"      # example: SCSS runs css/ checks
)

# ── Adding a new check ────────────────────────────────────────────────────────
# 1. Create an executable script in pre-commit.d/<scope>/
#    - pre-commit.d/all/   → runs on every staged file
#    - pre-commit.d/<scope>/ → runs on files whose extension maps to <scope>
# 2. Name it NN-description (e.g. 05-no-exit) — NN controls run order.
# 3. Interface:
#      $1  path to temp file containing the staged file content
#      $2  original repo-relative file path (use this in error output)
#    Print error detail to stdout. Exit 1 on failure, 0 on pass.
# ─────────────────────────────────────────────────────────────────────────────

HOOKS_DIR="$(cd "$(dirname "$0")" && pwd)"
CHECKS_DIR="$HOOKS_DIR/pre-commit.d"

# Resolve a file extension to its mapped scope. Prints the scope and returns 0
# on success, prints nothing and returns 1 if no mapping exists.
get_scope() {
  local ext="$1" entry
  for entry in "${EXT_MAP[@]}"; do
    if [ "${entry%%:*}" = "$ext" ]; then
      printf '%s' "${entry#*:}"
      return 0
    fi
  done
  return 1
}

# ── Main ──────────────────────────────────────────────────────────────────────

all_staged=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null) || true
[ -z "$all_staged" ] && exit 0

tmpdir=$(mktemp -d /tmp/pre-commit-XXXXXX)
trap 'rm -rf "$tmpdir"' EXIT

hook_failed=0
counter=0

while IFS= read -r file; do
  counter=$((counter + 1))
  tmp="$tmpdir/$counter"
  git show ":$file" > "$tmp"

  ext="${file##*.}"
  scope=$(get_scope "$ext") || scope=""

  # Build the list of scope dirs that apply to this file
  scope_dirs=("$CHECKS_DIR/all")
  if [ -n "$scope" ] && [ -d "$CHECKS_DIR/$scope" ]; then
    scope_dirs=("${scope_dirs[@]}" "$CHECKS_DIR/$scope")
  fi

  file_header_shown=0

  for scope_dir in "${scope_dirs[@]}"; do
    [ -d "$scope_dir" ] || continue

    for check in "$scope_dir"/*; do
      [ -f "$check" ] && [ -x "$check" ] || continue

      # Derive a readable label from the filename (strip NN- prefix and dashes)
      label=$(basename "$check" | sed 's/^[0-9]*-//')
      label="${label//-/ }"

      output=$("$check" "$tmp" "$file" 2>&1)
      status=$?

      if [ "$status" -ne 0 ]; then
        if [ "$file_header_shown" -eq 0 ]; then
          printf '\n    %s\n' "$file"
          file_header_shown=1
        fi
        printf '      [FAIL] %s\n' "$label"
        [ -n "$output" ] && printf '%s\n' "$output"
        hook_failed=1
      fi
    done
  done

done <<< "$all_staged"

if [ "$hook_failed" -ne 0 ]; then
  printf '\n  Pre-commit checks failed. Fix the issues above before committing.\n\n'
  exit 1
fi

exit 0
